<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[var ya; stepanova]]></title>
        <description><![CDATA[Front end developer, blogger and cats lover.]]></description>
        <link>http://varya.me/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Mon, 09 Jun 2014 09:00:57 GMT</lastBuildDate>
        <atom:link href="http://varya.me//en/feed.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Varya Stepanova]]></author>
        <pubDate>Mon, 09 Jun 2014 09:00:40 GMT</pubDate>
        <item>
            <title><![CDATA[Using side drawers in mobile apps on Steroids.js]]></title>
            <description><![CDATA[<p>As a mobile apps user you may be already familiar to drawers.
They are quite popular solution for a side menu. Using <code>Steroids</code>
HTML5/JavaScript framework for hybrid mobile applications, you
can bring such an interface solution into your product very easy.</p>
<excerpt/>

<p>The usage of drawers explained here is demonstrated in the <a href="https://github.com/AppGyver/kitchensink">Steroids
Kitchensink</a> open source application.
This is now being developed set of most useful examples for Steroids.
As the application is constantly changing, I will freeze the code examples
at <a href="https://github.com/AppGyver/kitchensink/tree/ceacb0ea80799b1d81454e2e966b553b807fbadc">28 May 2014</a>.</p>
<p>To explore the application in your mobile device or in a
simulator clone the repository and run the project. You may need some information
about how to start Steroids projects. That can be learned from tutorials:</p>
<ul>
<li><a href="https://academy.appgyver.com/categories/1-setup-and-getting-started/contents/1-installing-steroids">Installing
Steroids</a></li>
<li><a href="https://academy.appgyver.com/categories/1-setup-and-getting-started/contents/2-hello-world">Hello World application</a></li>
</ul>
<p>Or from my recent article about <a href="/en/posts/html5-mobile-app-width-native-ui/">HTML5 mobile apps with native UI on
Steroids</a>.</p>
<p>Once run the project you will see a page with a list of examples
and a navigation bar.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9652/14441195.32/0_8477d_3b6d66a5_L.png" width="282" height="500" border="0"/></p>
<p>The button to teh left of a menu bar opens a side menu. But before we start to
study side drawers let&#39;s look at how this button is shown.</p>
<p>The initial view is coded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/views/example/index.html"><code>app/views/example/index.html</code></a>.
This is an angular view with directives for the list and for the navigation bar.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">ng-controller</span>=<span class="hljs-value">"IndexCtrl"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">navigation-bar</span> <span class="hljs-attribute">title</span>=<span class="hljs-value">"Steroids Kitchensink"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">left-button</span> <span class="hljs-attribute">icon</span>=<span class="hljs-value">"/vendor/icons8/menu-32"</span>
        <span class="hljs-attribute">onTap</span>=<span class="hljs-value">"showMenu()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">left-button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">navigation-bar</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>The <code>navigation-bar</code> directive is custom and described in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/directives/navigationBar.coffee"><code>app/directives/navigationBar.coffee</code></a>.
Using such a directive rather than <code>steroids.view.navigationBar</code> helpers at every page is
more useful for the applications with many views.</p>
<p>Indeed inside the directive the same helpers are used. But declaring navigation bar
title and buttons in the view makes our programmers lifes a little bit
easier.</p>
<p>Here the navigation bar titled &quot;Steroids Kitchensink&quot; contains a &quot;hamburger&quot;
menu button which responds to the tapping with calling <code>showMenu</code> methods of
the corresponding controller.</p>
<p>This controller is coded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/controllers/example.coffee"><code>app/controllers/example.coffee</code></a>.
As you can see, the <code>showMenu</code> method is pretty short.</p>
<pre class="highlight"><code class="hljs coffeescript">$scope.<span class="hljs-function"><span class="hljs-title">showMenu</span> = <span class="hljs-params">()</span>-&gt;</span>
  steroids.drawers.show {
    <span class="hljs-attribute">edge</span>: steroids.screen.edges.LEFT
  }
</code></pre>
<p>It uses the drawers <code>show</code> method and slide the initial view to
the right which uncovers the menu view.</p>
<p>Of course, the code needs to know what is the view we mean by &#39;left&#39;.
We have to provide it with such a knowledge declaring the list of drawers
in the <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/config/application.coffee#L39"><code>config/application.coffee</code></a>
configuration file.</p>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.drawers =
  <span class="hljs-attribute">left</span>:
    <span class="hljs-attribute">id</span>: <span class="hljs-string">"sidemenu"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/views/sidemenu/index.html"</span>
    <span class="hljs-attribute">showOnAppLoad</span>: <span class="hljs-literal">false</span>
    <span class="hljs-attribute">widthOfDrawerInPixels</span>: <span class="hljs-number">250</span>
  <span class="hljs-attribute">options</span>:
    <span class="hljs-attribute">centerViewInteractionMode</span>: <span class="hljs-string">"Full"</span>
    <span class="hljs-attribute">closeGestures</span>: [<span class="hljs-string">"PanNavBar"</span>, <span class="hljs-string">"PanCenterView"</span>, <span class="hljs-string">"TapCenterView"</span>]
    <span class="hljs-attribute">openGestures</span>: [<span class="hljs-string">"PanNavBar"</span>, <span class="hljs-string">"PanCenterView"</span>]
    <span class="hljs-attribute">showShadow</span>: <span class="hljs-literal">true</span>
    <span class="hljs-attribute">stretchDrawer</span>: <span class="hljs-literal">true</span>
    <span class="hljs-attribute">widthOfLayerInPixels</span>: <span class="hljs-number">0</span>
</code></pre>
<p>Here the menu view file and some parameters. You can learn about
what they mean from a special tutorial about <a href="https://academy.appgyver.com/categories/3-user-interface-and-design/contents/98-configuring-drawers-on-app-load">configuring drawers</a>.</p>
<p>This will make the sidemenu shown.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9766/14441195.32/0_8477e_dbe7889e_L.png" width="282" height="500" border="0"/></p>
<p>To make it look like in the picture you need to provide a
corresponding view with the list of menu items. Here it is defined
in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/views/sidemenu/index.html"><code>app/views/sidemenu/index.html</code></a>.
This is pretty similar to the list of examples in the initial view. To make it function
we provide:</p>
<ul>
<li>a list of items and the corresponding view in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/www/data/sidemenu.json"><code>www/data/sidemenu.json</code></a>;</li>
<li>data model in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/models/sidemenu.js"><code>app/models/sidemenu.js</code></a>;</li>
<li>controller in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/controllers/sidemenu.coffee"><code>app/controllers/sidemenu.coffee</code></a>.</li>
</ul>
<p>From the drawers perspective the most important piece of code
to study is the controller. It says to hide the opened drawer if you
tap the currently active menu item. Opening other menu items goes
differently; it replaces the current central view with some animation.</p>
<pre class="highlight"><code class="hljs coffeescript"><span class="hljs-keyword">if</span> item.active
  steroids.drawers.hide {}
<span class="hljs-keyword">else</span>
  webView = <span class="hljs-keyword">new</span> steroids.views.WebView {
    <span class="hljs-attribute">id</span>: item.id,
    <span class="hljs-attribute">location</span>: item.url
  }
  steroids.drawers.hide {
    <span class="hljs-attribute">center</span>: webView
  }
</code></pre>
<p>Hiding the currently opened drawer with <code>steroids.drawers.hide</code> simply
gets back the previously shown central view.</p>
<p>If you want to show a different page, you would also use <code>steroids.drawers.hide</code> but
with an additional <code>center</code> parameter to pass the needed view. This view has to be
created in advance with <code>steroids.views.WebView</code>.</p>
<p>Besides, such a view must be configured as preloaded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/config/application.coffee#L31"><code>config/application.coffee</code></a>.</p>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.preloads = [
  {
    <span class="hljs-attribute">id</span>: <span class="hljs-string">"settings"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/views/settings/index.html"</span>
  }
]
</code></pre>
<p>Thus, with tapping on the <em>Settings</em> menu item you will get the settings
page shown.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9667/14441195.32/0_8477f_2aafe347_L.png" width="282" height="500" border="0"/></p>
<p>This page is empty yet. The upcoming posts will fill it in with something
interesting. Stay tuned :-)</p>
]]></description>
            <link>http://varya.me//en/posts/steroids-drawers</link>
            <guid isPermaLink="true">http://varya.me//en/posts/steroids-drawers</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 09 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Docpad with the taste of BEM]]></title>
            <description><![CDATA[<p>Let me present a stub for <strong>docpad-run</strong> project with
<strong>bem-built</strong> static assets. If you ever wanted to be
a generic blog holder equiped with nice and neat static
files, here we go.</p>
<excerpt/>

<h2 id="how-to-start">How to start</h2>
<p>You need install the docpad first. Follow their <a href="http://docpad.org/docs/install">Installation Guide</a>.</p>
<p>Then, the installation of the blog is super short and easy. Clone, fork or
copy from the <a href="https://github.com/varya/docpad-bem-stub">docpad-bem-stub repository</a>.
Then, go though the 3 installation steps:</p>
<pre class="highlight"><code class="hljs bash">npm install
./node_modules/bower-npm-install/bin/bower-npm-install
docpad run
</code></pre>
<p>With these 3 steps you will get:</p>
<ul>
<li>a local server with a generic docpad blog;</li>
<li><a href="http://bem.info/libs/bem-core/2.2.0/">bem-core</a> and <a href="http://bem.info/libs/bem-components/v2/">bem-components</a>
libraries of reusable CSS/JavaScript/templates code;</li>
<li>fully tuned static-build instructions which run on changes
in your source code;</li>
<li>initial blog structure.</li>
</ul>
<h2 id="how-to-write">How to write</h2>
<p>In the given structure you can write either pages or blog posts.
The posts are listed in the index page. Once you added a new
item, you can see it in this list and navigate to its page;
the docpad rebuilds from source automatically.</p>
<p>Place the pages as <code>*.html.md</code> files into <code>src/documents/pages</code>
directory. The posts are kept into <code>src/documents/posts</code>.</p>
<h2 id="how-to-develop-statics">How to develop statics</h2>
<p>The statics is developed with <a href="http://bem.info/">BEM</a>.
You can get CSS and JavaScript files for your pages in
<code>desktop.bundles</code> directory. The pages are built with blocks
from <code>desktop.blocks</code> folder.</p>
<p>The rebuild process for statics runs under docpad server.</p>
<p>Sometimes you may prefer to develop static pages separately.
For this run</p>
<pre class="highlight"><code class="hljs axapta">./node_modules/enb/bin/enb <span class="hljs-keyword">server</span>
</code></pre><p>You will get another server which rebuilds statics. It
produces static html files from <code>*.bemjson.js</code> files in
<code>desktop.bundles</code>. You can develop the layout inserting
json there and providing <code>BEMHTML</code> templates for the
corresponding block. Find the documentation about <code>BEMHTML</code>
here:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/intro/">BEMHTML quick start</a></li>
</ul>
<p>For the same blocks you can provide <code>*.css</code> and <code>*.js</code> files
and get them built into pages.</p>
<h2 id="how-to-publish">How to publish</h2>
<p>The blog is tuned to be deployed on GitHub. Thus, your
repository has to be named as <code>&lt;username&gt;.github.com</code>. You
can develop in its <code>source</code> branch. For deploying on
<code>&lt;username&gt;.github.io</code> host run this command:</p>
<pre class="highlight"><code class="hljs bash">docpad deploy-ghpages
</code></pre>
<p>This will create <code>master</code> branch of the repository whose
source is linked to the host.</p>
<p>You can also attach your own domain to the blog like I did.
Also, it is possible to host your blog in differently named
repository. However this will make you to provide changes
on <code>docpad.coffee</code> configuration file.<br/>
Study <a href="https://pages.github.com/">Github Pages</a> to learn more.</p>
<h2 id="why-docpad-">Why Docpad?</h2>
<p>This blog had been running on Jekyll for a while. This was an
acceptable soltuion for a quick start. However with the growth
of the posts base I started to suffer from not very fast
rebuilds. Also, sometimes providing changes into the blog
layout was hard, mostly due to the limitations of <code>liquid</code>
templates.</p>
<p>I&#39;ve decided that <a href="http://docpad.org/">Docpad</a> should be much
better alternative. It is served as an npm package, possible to
be extended with plugins and has an active fast-growing
developers community.</p>
<p>The <code>docpad-bem-stub</code> gives you initial structure, from which
you already can write and publish. If you want to provide changes
into the build process, modify the templates or extend with
plugins, <a href="http://docpad.org/">learn at Docpad website</a>.</p>
<p>Moreover, <a href="http://stackoverflow.com/">Stackoverflow</a> indeed already
has an answer to almost all the questions you have. If not, create a new
one.</p>
<h2 id="why-bem-">Why BEM?</h2>
<p>BEM is a very flexible modular solution for frontend which
enables to develop reusable CSS and JavaScript components. Plus, some code
can be taken from their open source libraries.</p>
<p>You can learn a lot about BEM from <a href="/en/content">my articles and talks</a>
or at the <a href="http://bem.info/">official BEM site</a>.</p>
<h2 id="inside-about">Inside about</h2>
<p>Above I described all you need to know for using your blog. Below there
are a little more technical details on what is behind.</p>
<h3 id="enb">ENB</h3>
<p>I use <a href="https://github.com/enb-make/enb">enb</a> for building pages with block
components. This solution is preferable to bem-tools because of it is much
faster. When rebuilding pages on every change, this is sensetive.</p>
<h3 id="i-bem-js-and-modules">i-bem.js and modules</h3>
<p>I personally love that this solution brings <code>i-bem.js</code> library to the
project. Hope to demonstrate its amazing capabilities here in near future.
But before I stuff my blog with complex JavaScript components, you
can see some examples and very detailed explanations in <a href="http://bem.info/tutorials/bem-js-tutorial/">Step-by-step tutorial on
i-bem.js</a>.</p>
<p>Another JavaScript feature you can enjoy is <a href="/en/issues/ym-modular-system">YM modular system</a>.
These are JavaScript modules with asynchronious resolving.</p>
<h3 id="bemhtml">BEMHTML</h3>
<p>As mentioned above, <code>BEMHTML</code> is a templating solution. Being JavaScript-based,
these templates can be applied on both server and client side. There are
a couple of documents for a deeper dive into it here:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/rationale/">BEMHTML templates description</a></li>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/reference/">BEMHTML tutorial</a></li>
</ul>
<h3 id="bem-core-and-bem-components">bem-core and bem-components</h3>
<p>BEM is also nice for a possibility to borrow the components from libraries.
<code>docpad-bem-stub</code> uses 2 now available libraries:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/">bem-core</a></li>
<li><a href="http://bem.info/libs/bem-components/v2/">bem-components</a></li>
</ul>
<p>I hope to see more in the future.</p>
<h2 id="what-next-">What next?</h2>
<p>Indeed everything can be improved. These are my thoughts on how
to continue.</p>
<ul>
<li>detect changes in static files<br/>
Docpad watches over the changes in <code>src</code> directory. This means that
when developing statics you will not get the rebuild. I am thinking
on running <code>enb server</code> under <code>docpad run</code> and proxy. This maybe
better than watch over a lot of files in <code>desktop.blocks</code>, <code>desktop.bundles</code>
and all the libraries.</li>
<li>css preprocessors<br/>
The blog styles are in pure CSS now. But with a little
change into enb configuration we can learn it to build with
preprocessors.</li>
<li>fresh design<br/>
Creating a simple layout is the most difficult design task. Don&#39;t you agree?</li>
<li>nice initial posts<br/>
This is even harder than the desing tasks but I think the users feel much
more comfortable when getting a blog with predefined texts.</li>
</ul>
<p>If you feel your oats and want to do your bit, fork <a href="https://github.com/varya/docpad-bem-stub">the repository</a>
and start :-)</p>
]]></description>
            <link>http://varya.me//en/posts/docpad-with-bem-taste</link>
            <guid isPermaLink="true">http://varya.me//en/posts/docpad-with-bem-taste</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 04 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[HTML5 mobile apps with native UI on Steroids]]></title>
            <description><![CDATA[<p>Recently I attended <a href="http://2014.front-trends.com/">Front Trends 2014</a> in Warsaw.
This is an awesome conference which you should (no, definitely have to!) attend
in 2015. Besides incredible main programm Front Trends provides a set of Lighting Talks.
This year I was a part of it presenting <a href="http://www.appgyver.com/steroids">Steroids</a>,
a framework and a toolkit for developing HTML5 mobile apps. If you did not have
a chance to hear it, this offline text presentation is for you.<excerpt/></p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#Cover">
  </iframe>
</div>

<p>Being an absolute newbie in developing mobile apps I decided to showcase
Steroids because it enables me to create pretty native-looking application
and smoothly go through the developing and releasing flow in a few minutes.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#summary">
  </iframe>
</div>

<p>The Steroids toolkit is a CLI; it brings Steroids JavaScript framewrok into
your project and takes care of building an app, developing flow, debugging
and releasing. It is based on NodeJs, so you have to have it installed.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#3">
  </iframe>
</div>

<p>The required version for now is <code>0.10.25</code>. Follow the <a href="http://academy.appgyver.com/categories/1/contents/1">Installation and Setup
Guide</a>.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#4">
  </iframe>
</div>

<p>Your very first start would be creating a project using <code>steroids create</code>
command. Then, typing <code>steroids connect --watch</code> in the gotten project
folder launches steroids process. The <code>--watch</code> flag as you can guess tells
Steroids to watch over the file changes, rebuild the app and push the results
to the connected devices.</p>
<p>You can connect a physical smartphone to the project. After running
<code>steroids connect</code> you get a web page with a QR code opened in your browser.
Use <code>AppGyver Scanner</code> to read this QR code, it will bring the application
into your phone and keep it connected.</p>
<div style="text-align:center;">
<a href="https://itunes.apple.com/us/app/appgyver-scanner/id575076515?mt=8"
target="_blank"><img alt="Appstore" class="appstore_icon"
src="https://share.appgyver.com/assets/appstore-df950585b54bd081a7826913fc715cd4.png"></a>
<a href="https://play.google.com/store/apps/details?id=com.appgyver.android&amp;feature=nav_result#?t=W251bGwsMSwxLDMsImNvbS5hcHBneXZlci5hbmRyb2lkIl0."
target="_blank"><img alt="Googleplay" class="appstore_icon"
src="https://share.appgyver.com/assets/googleplay-2cef882d62e402fbdbfe8cdac5794069.png"></a>
</div>

<p>Another way to watch the app is to bring it into a desktop simulator.
To do this, type <code>simulator</code> in the terminal wich launched
<code>steroids connect</code>.</p>
<p>You can change the application source files. E.g. edit a text
in <code>www/index.html</code> and make sure that the app in the connected device
or in the simulator has been changed.</p>
<p>To provide more powerful changes you can learn from the examples
and tutorials. Run <code>steroids generate</code> command and get the relevant
code.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#5">
  </iframe>
</div>

<p>You can learn from this code examples, from <a href="http://academy.appgyver.com/">tutorials</a>
and <a href="http://docs.appgyver.com/en/stable/index.html">API Docs</a>. 
Below I demonstrated some of the features which enable
to use <em>native UI</em>.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#examples-list">
  </iframe>
</div>

<p>Let us start with showing the native tabs.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#7">
  </iframe>
</div>

<p>In the <code>config/application.coffee</code> file you can find a commented
example of defining a list of tabs with their icons and
locations (URLs) they lead to.</p>
<p>In my application I created 3 tabs. They are for</p>
<ul>
<li>index.html</li>
<li>notificationExample.html</li>
<li>knowledge.html</li>
</ul>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.tabBar.enabled = <span class="hljs-literal">true</span>
steroids.config.tabBar.tabs = [
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Index"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/pill@2x.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/index.html"</span>
  },
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Notifications"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/bell.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/notificationExample.html"</span>
  },
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Knowledge base"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/coding.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/knowledge.html"</span>
  }
]
</code></pre>
<p>Place the pages into <code>www</code> directory and keep them empty yet.
Do not forget the icons. You can borrow the whole <a href="https://github.com/varya/steroids-fronttrends2014/tree/master/www/icons">icon
folder</a>.</p>
<p>After making the change wait for rebuild and check.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9088/14441195.32/0_84262_ae854cb8_orig.png" width="340" height="89" border="0" title="" alt=""/>
</div>

<p>Next, we can play with notifications.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#8">
  </iframe>
</div>

<p>Place these buttons inside the <code>&lt;body&gt;</code> container of the
<code>www/notificationExample.html</code> file.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">button
</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showAlert()"</span>&gt;</span>Show alert dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button
</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showConfirm()"</span>&gt;</span>Show confirm dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button
</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showPrompt()"</span>&gt;</span>Show prompt dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button
</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"vibrate()"</span>&gt;</span>Vibrate the device<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
</code></pre>
<p>As you can see, they run different JavaScript functions on
touch. To finish the page you need to define these functions
in the <code>&lt;head&gt;</code> or linked <code>*.js</code> file. Each function demonstrates
a kind of notification which are:</p>
<ul>
<li><code>navigator.notification.alert</code></li>
<li><code>navigator.notification.confirm</code></li>
<li><code>navigator.notification.prompt</code></li>
<li><code>navigator.notification.vibrate</code></li>
</ul>
<p>Borrow the JavaScript code from <a href="https://github.com/varya/steroids-fronttrends2014/blob/master/www/notificationExample.html#L15">my repo</a>.</p>
<p>Now you can navigate to this page using the tabs and try
each type of notification with tapping.</p>
<p>Another native element could be a button in the application navigation
bar.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#9">
  </iframe>
</div>

<p>The navigation bar can be modified with JavaScript on Steroids.
If you want it to be the same across all the application pages,
provide this JavaScript in the <code>www/javascripts/application.js</code> file
which is linked to all the <code>*.html</code> files.</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> loginButton = <span class="hljs-keyword">new</span> steroids.buttons.NavigationBarButton();
loginButton.title = <span class="hljs-string">"the Button"</span>;

loginButton.onTap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    navigator.notification.alert(
        <span class="hljs-string">'You tapped the button!'</span>,
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>},
        <span class="hljs-string">'the Alert'</span>,
        <span class="hljs-string">'I did!'</span>
    );
}

steroids.view.navigationBar.update({
    buttons: {
      right: [loginButton]
    }
})
</code></pre>
<p>This will bring the button to the right side of the
navigation bar. Tapping on it you can see a notification; one
of those you studied recently.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9115/14441195.32/0_84264_7f27d435_L.png" width="282" height="500" border="0" title="" alt=""/>
</div>

<p>The last of native UI examples in this app is showing
modal views.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#10">
  </iframe>
</div>

<p>Add this button into <code>www/index.html</code>:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">a
</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showModal()"</span>&gt;</span>Open modal<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
</code></pre>
<p>And code <code>showModal</code> method to open a view as a modal.</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showModal</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> webView =
    <span class="hljs-keyword">new</span> steroids.views.WebView(<span class="hljs-string">"/views/modalExample/show.html"</span>);
  steroids.modal.show(webView);
}
</code></pre>
<p>The related view is a piece of html, which you should place into
<code>app/views/modalExample/show.html</code>. BTW, it has to have an interface
element closing the view. To make the process faster, pick up the
<a href="https://github.com/varya/steroids-fronttrends2014/blob/master/app/views/modalExample/show.html">code from the application repo</a>.</p>
<p>With this and <a href="http://docs.appgyver.com/en/stable/steroids_Steroids%20Native%20UI_index.md.html#Steroids%C2%A0Native%C2%A0UI">other UI features</a>
you can build a mobile interface which looks absolutely native for a
device where you application runs.</p>
<p>Once finished coding (or even in process) you may need to show the
application to your friend, client or Mom.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#sharing">
  </iframe>
</div>

<p>You can use the QR code from the beginning of our session which can
bring your application to any any device directly from your computer.
However this only will work if them both are connected to the same
network.</p>
<p>If you want to share with someone remotely, deploy your app into the cloud.
The <code>steroids deploy</code> command serves for it. As a result you get
a page (also with a QR code) which can be scanned with AppGyver Scaner on
a phone and thus your pal get the same app from the cloud.</p>
<p>All your applications in the cloud can be shared, tuned and built with
web interface at <a href="https://cloud.appgyver.com/applications">cloud.appgyver.com</a>.</p>
<p>From there you also push the app into AppStore and GooglePlay.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9062/14441195.32/0_84265_d03d686e_orig.png" width="500" height="327" border="0" title="" alt=""/>
</div>

<p>This is easy. As easy that a newbie can develop an app in a few minutes
and show you the how-to.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#links">
  </iframe>
</div>

<p>You can learn more about Steroids and Cordova (Steroids is based on PhoneGap)
at the <a href="http://academy.appgyver.com/">AppGyver Academy</a> where you find:</p>
<ul>
<li>detailed tutorials,</li>
<li>documentation,</li>
<li>big community of devs.</li>
</ul>
<p>And, of course, you can read <a href="/en/posts/">this blog</a>. I promise to share my next findings
regarding Steroids soon :-)</p>
]]></description>
            <link>http://varya.me//en/posts/html5-mobile-app-width-native-ui</link>
            <guid isPermaLink="true">http://varya.me//en/posts/html5-mobile-app-width-native-ui</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 26 May 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Switching to bem-core#v2]]></title>
            <description><![CDATA[<p>The <code>bem-core</code> library goes futher and there already is <code>2.0.0</code> version
available. This blog was safely switched to the new major version with
<a href="https://github.com/varya/varya.github.com/commit/f21f810b7cb4e16206ef3d088a8b2c38b615f8f3">some diff to the
code</a>.
Now so can do you. Careful examination of the version changelog will help you
with it. Look how I did this.<excerpt/></p>
<p>When a new bem library version is released its changelog is published on the
official BEM website. You can examine the <a href="http://bem.info/libs/bem-core/2.0.0/changelog/">list of changes for bem-core
2.0.0</a>.</p>
<p>The changelog is divided into 3 parts: breaking, marjor and minor changes.</p>
<p>Breaking changes takes most of your attention. As you can see, they declare
removing of some basic methods as well as hosting some code in different
repositories. Thus, if you used some of the listed methods, the switch pushes
you to refactor your code a little bit.</p>
<p>The major changes are less critical but might case some code changes as well. In
this version BEM team provided <a href="https://github.com/bem/bem-core/issues/382">new syntax for defining the blocks in
JavaScript</a>. This change is not
breaking as the old syntax still works. However it is nice to go through a small
refactoring and switch to the new type of module declaration keeping your code
neat for the future.</p>
<p>The same goes for the <a href="https://github.com/bem/bem-core/issues/410">change to DOM
helpers</a>. With getting the context
as a result of using those helpers you can get rid of a couple of lines per
block.</p>
<p>Summing it up, switcing to the new version should be your happiest time as you
have a ready-made excuse to dive into refactoring.</p>
]]></description>
            <link>http://varya.me//en/issues/switching-to-bem-core-2</link>
            <guid isPermaLink="true">http://varya.me//en/issues/switching-to-bem-core-2</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 15 May 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[BEML - an HTML preprocessor for BEM]]></title>
            <description><![CDATA[<p>Depending on a project people prefer different ways to adapt BEM.
This results 
into a range of tools for our choice. Today, I am translating Maxim Shkalin&#39;s
description of the <code>BEML</code> templating pre-processor.</p>
<p>Willing to lighten the development with BEM I propose a tiny extension for the
HTML syntax (yes, I used to writ all those long CSS classes manually). As the
name <code>BEMHTML</code> is greedily taken by the Yandex guys, let us call it <code>BEML</code>.<excerpt/></p>
<h2 id="objective">Objective</h2>
<ol>
<li>Smooth learning curve<br/>
HTML-syntax with no need to transform one language into another.</li>
<li>Portability<br/>
The tool has to be easy to use with other languages.</li>
<li>Compatiblity with template engines<br/>
Instead of trying to replace them.</li>
<li>Simplicity<br/>
Easy to use at any project.</li>
</ol>
<p>It might be my habit, but I do not see the need to transform JSON into HTML.
BEMJSON page description usually looks like spaghetti and is very hard to read
due to its syntax. Also I do not think that HTML is wrong. AngularJS has already
shown that HTML can be much flexible than now. Thus, I decided to follow this
example.</p>
<p>Moreover, there is anothe problem with using BEMHTML. You need Node.js running
for your backend; or use another JavaScript engine for PHP or Rython with dirty
hacks like V8JS or PyV8. The otehr way round could be preparation of a rendered
template, but this sounds even more unnatural.</p>
<p>It would be nice to have a JavaScript-preprocessor and a relative Grunt task
which can be used for creating the prototypes. Then, with transforming to PHP
you can use the same templates in the backend.</p>
<h2 id="concept">Concept</h2>
<p>I had a lot of ideas how to extend HTML with inheritance, includes and loops.
But finally I cut them off. It would be too complex to support and then provide
the portability. Besides, there is a lot of other template engines; I would
rather enter into alliance with them than to compete. Finally I got not a
template engine but a preprocessor (or postprocessor) to the current one.</p>
<p>The scenario is the following. First, create BEML markup using your template
engine. Then, past it not to the client but to the post-processor which turns
BEM syntax into HTML. Funally the HTML goes to the client.</p>
<p>Or, there is a faster way for the braves. You can change your template with
pre-processor which turns BEM attributes into HTML, cache it and use this
chached copy with your dear template engine. Indeed, the pre-processor does not
touch the template engine code.</p>
<h2 id="syntax">Syntax</h2>
<p>This is very simple, you just use 4 more attributes like <code>block</code>, <code>elem</code>, <code>mod</code>
and <code>mix</code>. I suppose it is clear what each of them is responsible for. For the
complex values you can use light JSON dialect with no quotation marks and
optional curly braces. Finally the tool turns this code:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">block</span>=<span class="hljs-value">"b-animals"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">elem</span>=<span class="hljs-value">"cat"</span> <span class="hljs-attribute">mod</span>=<span class="hljs-value">"size:big, color:red"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>into the following HTML.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"b-animals"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"b-animals__cat
              b-animals__cat_size_big
              b-animals__cat_color_red
              "</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>Much readable.</p>
<p>Full information about the syntax you can learn from the <a href="https://github.com/zenwalker/node-beml">README on GitHub</a>.</p>
<h2 id="try-now">Try now</h2>
<pre class="highlight"><code class="hljs bash">npm install beml
</code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> beml = <span class="hljs-built_in">require</span>(<span class="hljs-string">'beml'</span>);
<span class="hljs-keyword">var</span> template = <span class="hljs-string">'&lt;div block="b-block" mod="size:big"&gt;&lt;/div&gt;'</span>;

beml.process(template, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, html)</span> {</span>
  console.log(html);
});
</code></pre>
<h2 id="author">Author</h2>
<p>This article is a translaton.
The original article by Maxim Shkalin was <a href="http://zenwalker.ru/blog/2014/1/html-preprocessor-for-bem.html">posted in his
blog</a>. Follow him in the social networks:
<a class="link social-ico__ico social-ico__ico_in-text social-ico__ico_type_twitter"
href="https://twitter.com/zenwalker2/" target="_blank"></a>
<a class="link social-ico__ico social-ico__ico_in-text social-ico__ico_type_github"
href="https://github.com/zenwalker/" target="_blank"></a></p>
]]></description>
            <link>http://varya.me//en/issues/beml-html-preprocessor</link>
            <guid isPermaLink="true">http://varya.me//en/issues/beml-html-preprocessor</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 08 May 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Borschik helps with remote static assets]]></title>
            <description><![CDATA[<p>Last week I met the need to develop a web site which static assets have to be
hosted on a different server and respond by different URLs than its HTML. This
is the requirement to all the static files: stylesheets and JavaScript linked to
the page as well as imges and fonts mentioned in HTML, CSS and JavaScript
code.<excerpt/> However it is obvious that these resources should be local when developing.
Thus, the challenge was to introduce a piece of magic which knows where we aim
to host the statics and transforms all the relative paths into absolute ones
according to it.</p>
<p>The tools which helped me is called
<a href="http://bem.info/tools/optimizers/borschik/">Borschik</a>. The name is funny.
Besides it reffers to a famous Russian/Ukranian soup, it also alludes to a word
&quot;сборщик&quot; [sborschik], and so might be translated as</p>
<p><strike>ass</strike>embler. &quot;Removing the ass part&quot; as one of my friends says.
:-)</p>
<center>
<iframe src="//embed.gettyimages.com/embed/135591409?et=B_T3l-shrE-pr9-ELe_wJw&sig=5haG67PAzCxGourA96ZB7m9LwSket1v9PpvXEXNIkBM=" width="508" height="407" frameborder="0" scrolling="no"></iframe>
</center>

<p>In the <a href="https://github.com/varya/st-deliverer">varya/st-deliverer</a> public repository
you can find a stub project illustrating the solution.</p>
<h3 id="project-structure">Project structure</h3>
<p>As you will be able to see later <code>borschik</code> is very flexible. So you can use any
project structure. In my project I store everything in
<a href="b.com/varya/st-deliverer/tree/master/src">src folder</a>.
When building I get HTML files in
<a href="https://github.com/varya/st-deliverer/tree/gh-pages/dist/html">dist/html directory</a>.
Check out the code and make sure that static files are linked from a different
server by their absolute paths.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Deliver static assets with Borschik<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link
</span>      <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span>
      <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://varya.github.io/stor.../styles.css"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body
</span>    <span class="hljs-attribute">class</span>=<span class="hljs-value">"page"</span>
    <span class="hljs-attribute">background</span>=<span class="hljs-value">"http://varya.github.io/stor.../grungy.jpg"</span>&gt;</span>
  ...
</code></pre>
<p><a href="http://varya.me/st-deliverer/dist/html/">Open in your browser</a> to enjoy my visual
design and a tom-cat.</p>
<h3 id="bring-borschik-to-your-project">Bring borschik to your project</h3>
<p>Borschik is an npm package. So, you can install it globally by runing</p>
<pre class="highlight"><code class="hljs bash">npm install -g borschik
</code></pre>
<p>I personally prefer local project dependencies, so my project has a
<a href="https://github.com/varya/st-deliverer/blob/master/package.json">package.json</a>
file:</p>
<pre class="highlight"><code class="hljs javascript">{
  ...
  <span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"borschik"</span>: <span class="hljs-string">"0.4.2"</span>
  },
  ...
}
</code></pre>
<h3 id="configuration">Configuration</h3>
<p>Before we start the magic transformation it is needed to instruct <code>borschik</code> what
to transform and how to transform. The <a href="https://github.com/varya/st-deliverer/blob/master/.borschik">.borschik</a>
configuration file serves for that.</p>
<pre class="highlight"><code class="hljs javascript">{
  <span class="hljs-string">"paths"</span> : {
    <span class="hljs-string">"src/img/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/img/"</span>,
    <span class="hljs-string">"src/css/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/css/"</span>,
    <span class="hljs-string">"src/font/"</span>: <span class="hljs-string">"http://varya.github.io/storage/fonts/"</span>

  }
}
</code></pre>
<p>Note that you can tune different replacements for different paths. Here I tried
to illustrate with the fonts.</p>
<h3 id="run-the-command">Run the command</h3>
<p>Run borschik over a file which contains links to local static assets, and you
will get the transformation result. For example,</p>
<pre class="highlight"><code class="hljs bash">./node_modules/borschik/bin/borschik \
  --input=src/css/styles.css
</code></pre>
<p>Fot the building process you will also need an <code>--output</code> flag to instruct
<code>borschik</code> where to place the result.</p>
<p>Borschik knows the syntax of web technologies. It will not touch the links
mentioned in text, for example.</p>
<h3 id="build-system">Build system</h3>
<p>Now you can use <code>borschik</code> in your project build process. I simply wrote a
<a href="https://github.com/varya/st-deliverer/blob/master/Makefile">Makefile</a> with a
lot of help from <a href="https://github.com/alexeyten">@alexeyten</a> (tnx!).
There is also a grunt plugin <a href="https://github.com/megatolya/grunt-borschik">megatolya/grunt-borschik</a>.<br/>
Indeed, <code>borschik</code> is included into <a href="http://bem.info/tools/bem/bem-tools/">bem-tools</a>
and <a href="https://github.com/enb-make/enb">enb</a> — the two competitive solutions for
building the projects with BEM structure.</p>
<h3 id="result">Result</h3>
<p><a href="http://varya.me/st-deliverer/dist/html/">Check the cat again</a>. Still there?</p>
<p>You also can learn about other features of <code>borschik</code> from the article:
<a href="http://bem.info/articles/borschik/">http://bem.info/articles/borschik/</a>.</p>
]]></description>
            <link>http://varya.me//en/issues/borschik-static-assets</link>
            <guid isPermaLink="true">http://varya.me//en/issues/borschik-static-assets</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 09 Apr 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[YM Modular System. Why?]]></title>
            <description><![CDATA[<p>The recently published <a href="http://bem.info/tutorials/articles/bem-js-tutorial/">step-by-step tutorial on
i-bem.js</a> mentioned <strong>YM
modular system</strong> as a base for component JavaScript solution behind BEM. Why do
we need another modular system? Let us see...</p>
<excerpt/>

<p>The author of YM modules, <a href="https://github.com/dfilatov">Dmitry Filatov</a> recently
came up with an <a href="http://habrahabr.ru/post/213627/">article about YM modules</a> in
Russian. And below you can find the translation.</p>
<hr/>

<p>So, one more modular system? Besides CommonJS and AMD? Why should we care?</p>
<p>I will not write why modules and modular systems are needed, there are plenty of
articles about it. Let us rather proceed to the main question: why do we need
<em>another</em> modular system?<br/>
For sure, there are CommonJS and AMD, but working on large projects with them I faced
 large drawbacks. One is that they are synchronous. This is not fatal, but in my
project we often had to provie different hacks for it.</p>
<p>Let us say, we have 3 modules: moduleA, moduleB and moduleC. moduleC depends on
both moduleA and moduleB. Initially I will describe this in code for all the
three solutions:</p>
<h4 id="commonjs">CommonJS</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">module.exports = <span class="hljs-string">'A'</span>;
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript">module.exports = <span class="hljs-string">'B'</span>;
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">'A'</span>); 
    moduleB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'B'</span>);

module.exports = moduleA + moduleB + <span class="hljs-string">'C'</span>;
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleC = <span class="hljs-built_in">require</span>(<span class="hljs-string">'C'</span>);
console.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
</code></pre>
<h4 id="amd">AMD</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'A'</span>;
});
</code></pre>
<p><em>moduleB.js:</em>:</p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'B'</span>;
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'С'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleA, moduleB)</span> {</span>
    <span class="hljs-keyword">return</span> moduleA + moduleB + <span class="hljs-string">'C'</span>;
});
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">'С'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleC)</span> {</span>
    console.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
});
</code></pre>
<h4 id="ym">YM</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> {</span>
    provide(<span class="hljs-string">'A'</span>);
});
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> {</span>
    provide(<span class="hljs-string">'B'</span>);
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'C'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, moduleA, moduleB)</span> {</span>
    provide(moduleA + moduleB + <span class="hljs-string">'C'</span>);
});
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.require([<span class="hljs-string">'С'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleC)</span> {</span>
    console.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
});
</code></pre>
<p>Nothing interesting yet. All three examples are similar, although you may
notice the <code>provide</code> callback in the YM example. What is it for?</p>
<p>Let us imagine a case that <code>moduleA</code> and <code>moduleB</code> cannot be resolved immediately
(synchronously, as it is required by CommonJS and AMD). Sometimes you need to
do an asynchronous action first. The simpliest example can be <code>setTimeout</code>.
There is no way to implement it elegantly with CommonJS and AMD.
But with <code>YM</code> it can be coded as follows:</p>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> {</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        provide(<span class="hljs-string">'A'</span>);
   });
});
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> {</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        provide(<span class="hljs-string">'B'</span>);
    });
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'C'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, moduleA, moduleB)</span> {</span>
    provide(moduleA + moduleB + <span class="hljs-string">'C'</span>);
});
</code></pre>
<p>Interestingly <code>moduleC</code> does not know anything about asynchronous actions in
its dependant modules. <em>Win!</em></p>
<h3 id="real-life-example">Real life example</h3>
<p>As for real file example, I often use the YandexMaps API
(<a href="http://api.yandex.com/maps/">http://api.yandex.com/maps/</a>, API of
<a href="http://maps.yandex.com/">Yandex.Maps</a>
public service). Yandex.Maps API has a complex loading scheme and this cannot be
done synchronously. This means that I cannot simply link it to a page
<code>&lt;script type=&quot;text/javascript&quot; src=&quot;url-of-ymaps.js&quot;&gt;&lt;/script&gt;</code> and be sure that
all the following scripts will get the API code ready. First I need to wait for
the event <code>ymaps.ready</code> to fire.</p>
<p>The project I am working for is quite complex; we have many classes inherited
from the basic API. For example, we have a <code>ComplexLayer</code> class based on <code>ymaps.Layer</code>.
With YM modules it is simple to implement. We define a <code>ymaps</code> module which loads
the API code, waits for the <code>ymaps.ready</code> event and then provides itself. All
the modules which have the <code>ymaps</code> module as a dependency only start to resolve 
after this. As you can see, other modules know nothing about the asynchronicity of the
Yandex.Map API. <em>No hacks in code!</em></p>
<p><em>ymaps.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(
    <span class="hljs-string">'ymaps'</span>,
    [<span class="hljs-string">'loader'</span>, <span class="hljs-string">'config'</span>],
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, loader, config)</span> {</span>

    <span class="hljs-keyword">var</span> url = config.hosts.ymaps + <span class="hljs-string">'/2.1.4/?lang=ru-RU'</span> +
              <span class="hljs-string">'&amp;load=package.full&amp;coordorder=longlat'</span>;

    loader(url, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        ymaps.ready(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            provide(ymaps);
        });
    });
});
</code></pre>
<p>There are 2 other modules in use here: <code>loader</code> and <code>config</code>. I do not show
their code, but the first one loads scripts and the second one is a hash with
constant values.</p>
<p><em>ComplexLayer.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'ComplexLayer'</span>, [<span class="hljs-string">'inherit'</span>, <span class="hljs-string">'ymaps'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, inherit, ymaps)</span> {</span>
    <span class="hljs-keyword">var</span> ComplexLayer = inherit(ymaps.Layer, ...);

    provide(ComplexLayer);
});
</code></pre>
<p>We can do the same if jQuery is needed. There is a module to load jQuery:</p>
<pre class="highlight"><code class="hljs javascript">modules.define(
    <span class="hljs-string">'jquery'</span>,
    [<span class="hljs-string">'loader'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, loader)</span> {</span>

    loader(<span class="hljs-string">'//yandex.st/jquery/2.1.0/jquery.min.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        provide(jQuery.noConflict(<span class="hljs-literal">true</span>));
    });
});
</code></pre>
<p>Then we make other modules dependent on <code>jquery</code> module.</p>
<p>Thus, the whole project code is represented with modules. There is no global, no
need for agreement on the order of linking the scripts (including third-party ones),
no dirty hacks for asynchronicity.</p>
<p>And to wrap up, let me demonstrate you the YM modular system API (indeed, it has more
methods, and these are only the basic ones).</p>
<p><em>Defining a module:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">void</span> modules.define(
    <span class="hljs-built_in">String</span> moduleName,
    [<span class="hljs-built_in">String</span>[] dependencies],
    <span class="hljs-built_in">Function</span>(
        <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span> objectToProvide) provide,
        [<span class="hljs-built_in">Object</span> resolvedDependency, ...],
        [<span class="hljs-built_in">Object</span> previousDeclaration]
    ) declarationFunction
)
</code></pre>
<p><em>Requiring a module:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">void</span> modules.require(
    <span class="hljs-built_in">String</span>[] dependencies,
    <span class="hljs-built_in">Function</span>(
        [<span class="hljs-built_in">Object</span> resolvedDependency, ...]
    ) callbackFunction
)
</code></pre>
<p>The project is open source and hosted at GitHub:
<a href="https://github.com/ymaps/modules">github.com/ymaps/modules</a>.</p>
]]></description>
            <link>http://varya.me//en/issues/ym-modular-system</link>
            <guid isPermaLink="true">http://varya.me//en/issues/ym-modular-system</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 24 Mar 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[JavaScript in BEMJSON]]></title>
            <description><![CDATA[<p>We usually start developing a web site prototyping the interface and then
implementing HTML/CSS and bacis JavaScript. In case
of using the full BEM stack a tranformation from prototype to a functioning web
site goes smoothly. You can clone the project from
<a href="https://github.com/bem/project-stub">project-stub</a> and create a static web page
as it was <a href="http://bem.info/articles/start-with-project-stub/">described
earlier</a>.</p>
<excerpt/>

<p>Thanks to <code>BEMHTML</code> templates, you do not need write all the HTML manually.
Describing page sructure in <code>BEMJSON</code> rather than writing all the tags manually
saves time. But sometimes this is still a lot of work to do, especially for large
pages.</p>
<p>Luckily BEMJSON can include JavaScript pieces to produce some blocks dymamically.
I created an example of such usage:</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'content'</span>,
            content: (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">var</span> res = [];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
                    res.push({
                        block: <span class="hljs-string">'button'</span>,
                        content: <span class="hljs-string">'Button '</span> + (i + <span class="hljs-number">1</span>)
                    });
                }
                <span class="hljs-keyword">return</span> res;
            })()
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page1/page1.bemjson.js">full
code</a></p>
<p>This JavaScript creates 10 <code>button</code> blocks when the page is being built with
<code>bem-tools</code>.
Check the <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page1/page1.html">result
page</a>
to see them.</p>
<p>Another example is a <code>menu</code> block. Such interface pieces usually consist of a
lot of items with minor differences which cases a lot of copy-paste on a page.
With JavaScript in BEMJSON this can be easily reduced.</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'menu'</span>,
            content: [
                {
                    title: <span class="hljs-string">'Index'</span>,
                    isSelected: <span class="hljs-literal">false</span>,
                },
                {
                    title: <span class="hljs-string">'Products'</span>,
                    isSelected: <span class="hljs-literal">true</span>
                },
                {
                    title: <span class="hljs-string">'Contact'</span>,
                    isSelected: <span class="hljs-literal">false</span>
                }
            ].map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span>{</span>
                <span class="hljs-keyword">var</span> block = {
                    block: <span class="hljs-string">'menu'</span>,
                    elem: <span class="hljs-string">'item'</span>,
                    content: item.title,
                    mods: {
                        selected: item.isSelected
                    }
                };
                <span class="hljs-keyword">return</span> block;
            })
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page2/page2.bemjson.js">full
code</a></p>
<p>This gives a <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page2/page2.html">page with a menu of 3 items</a>.
The bigger is the array of items, the more you save. Especially when the structure
of every item changes while developing.</p>
<p>Indeed, this feature is not needed when BEMJSON is a result of 1st layer templates
(like BEMTREE, priv.js) you can produce as much BEMJSON as is necessary. But with
initial development of a static web page, the JavaScript tricks help to avoid
copy-paste.</p>
]]></description>
            <link>http://varya.me//en/issues/javascript-in-bemjson</link>
            <guid isPermaLink="true">http://varya.me//en/issues/javascript-in-bemjson</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 20 Feb 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Blocks are bricks, and bundles are buildings]]></title>
            <description><![CDATA[<p>A couple of days ago I was asked about some basic things of using <a href="https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c">BEM project
stub</a>
from someone who is enjoying the full BEM stack (BEM-CSS, i-bem.js and BEMHTML
templates) for their projects. Answering the questions I promised to turn the
information into text as we always skip many important things mistakenly
considering them being primitive.</p>
<excerpt/>

<p>The quesion was about <code>.bem/make.js</code> configuration file which is needed if you
use <a href="http://bem.info/tools/bem/bem-tools/">bem tools</a> to build your pages. The
<a href="https://github.com/bem/project-stub/blob/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/make.js#L12">12th and 13th
lines</a>
describe regular expressions to match <code>blocks</code> and <code>bundles</code>. And the meaning of
these terms turned out to be unclear.</p>
<p>First of all, the expressions are to detect folders on the project file system.
Those which end with <code>.blocks</code> store blocks, and those which end with <code>.bundles</code>
store bundles. The <code>desktop.blocks</code> and <code>desktop.bundles</code> folders of the project
stub demonstrate this.</p>
<p>The purpose of <code>desktop.blocks</code> folder should be clear. As BEM is a modular
development pattern there has to be a place to store modules, the so-called
<code>blocks</code>. Each block has its own directory to keep all the files needed for this
particular interface module. E.g. <a href="https://github.com/varya/online-shop-dummy/tree/master/desktop.blocks">one project block
set</a>.</p>
<p>The <code>desktop.bundles</code> folder needs some comments. It stores pages, which are the
result of blocks applied. Every page has its own folder and inside you can find
different files needed for a page to function. Examine the <a href="https://github.com/varya/online-shop-dummy/tree/gh-pages/desktop.bundles">example
project</a>
again.</p>
<p>The difference is that block files are coded by a developer, as bundle files are
built with the tools. Block files are our dear CSS, JavaScript and sometimes templates.</p>
<pre class="highlight"><code class="hljs xml">├── desktop.blocks/
│   ├── goods/
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.bemhtml"</span>&gt;</span>goods.bemhtml<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.css"</span>&gt;</span>goods.css<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.deps.js"</span>&gt;</span>goods.deps.js<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   └── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.ie.css"</span>&gt;</span>goods.ie.css<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span></code></pre>

<p>Real world analogy of a BEM block (and actually any module of any modular
pattern) can be a buiding brick.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/6730/14441195.30/0_7e0f8_33c1c86c_L.jpg&quot;/">img
src=&quot;http://img-fotki.yandex.ru/get/6730/14441195.30/0_7e0f8_33c1c86c_L.jpg&quot;/</a></p>
<p>Bundle files are also what a browser can read: CSS, JavaScript, HTML. <em>None of
them was written by a person, they are built with BEM tools</em>. Have a look
inside to be sure that this is robot&#39;s code.</p>
<pre class="highlight"><code class="hljs xml">├── desktop.bundles/
│   ├── index/
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.css"</span>&gt;</span>_index.css<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.js"</span>&gt;</span>_index.js<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   ├── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js"</span>&gt;</span>index.bemjson.js<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
│   │   └── <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.html"</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span></code></pre>


<p>Think about bem tools as about building crane to pick up the bricks and make a
house with them.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/9058/14441195.30/0_7e0f3_ff76f66a_L.jpg&quot;/">img
src=&quot;http://img-fotki.yandex.ru/get/9058/14441195.30/0_7e0f3_ff76f66a_L.jpg&quot;/</a>
Besides <em>.js, </em>.css and *.html files there is the only one here written by a
developer. This is
<a href="https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js">index.bemjson.js</a>,
the JSON decription of what are the blocks on a page and what it their nested
structure. Sounds logical, as only we human can know what we would like to see
on a page. Everything else is produced by the <code>bem tools</code>. Once given
informaiton about which blocks to use for a page, they pick them up from
<code>desktop.blocks</code> set of blocks and do their job.</p>
<p>Extending the building-a-house example I can say that <code>page.bemjson.js</code> file
here is a draft.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e1ba_9dacd537_L.jpg&quot;/">img
src=&quot;http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e1ba_9dacd537_L.jpg&quot;/</a></p>
<p>But why do <code>bem tools</code> need the regular expessions?</p>
<p>This is quite easy. The folders <code>bem tools</code> operate with are <code>levels</code>. It can
help if you think about a level as about <code>a set</code>, a set of entities. There can be
a set of blocks wraped with <code>desktop.blocks</code> folder, and a set of result pages
wraped with <code>desktop.bundles</code> folder. In the
<a href="https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/levels">.bem/levels/</a>
cofiguration folder there are some instructions from which bem tools understand
what to do with those different types of levels.</p>
<p>Dividing your project entities into blocks and bundles makes it possible to have
different sets of blocks and different bundles built with those sets. For
example, you can store blocks to a desktop and touch versions of your web site
into the same repository as well as the pages built with them.</p>
<pre class="highlight"><code class="hljs avrasm">├── desktop<span class="hljs-preprocessor">.blocks</span>/
├── desktop<span class="hljs-preprocessor">.bundles</span>/
├── touch<span class="hljs-preprocessor">.blocks</span>/
└── touch<span class="hljs-preprocessor">.bundles</span>/</code></pre>

<p>Comming back to the real world, not only bricks are the modules but lego blocks
as well.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e0f6_f69c7d44_L.jpg&quot;">img
src=&quot;http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e0f6_f69c7d44_L.jpg&quot;</a></p>
<p>They also are to build a house. A pretty different house though.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/9326/14441195.30/0_7e0f4_3d999550_L.jpg&quot;/">img
src=&quot;http://img-fotki.yandex.ru/get/9326/14441195.30/0_7e0f4_3d999550_L.jpg&quot;/</a></p>
<p>Going futher you can detach code common for all the platforms and store it
separately.</p>
<pre class="highlight"><code class="hljs avrasm">├── common<span class="hljs-preprocessor">.blocks</span>/
├── desktop<span class="hljs-preprocessor">.blocks</span>/
├── desktop<span class="hljs-preprocessor">.bundles</span>/
├── touch<span class="hljs-preprocessor">.blocks</span>/
└── touch<span class="hljs-preprocessor">.bundles</span>/</code></pre>

<p>With that structure desktop version of a web site gets source code from both
<code>common.blocks</code> and <code>desktop.blocks</code> levels as touch version gets it from
<code>common.blocks</code> and <code>touch.blocks</code>.</p>
<p><a href="img
src=&quot;http://img-fotki.yandex.ru/get/6725/14441195.30/0_7e0f5_3e107fd4_L.jpg&quot;/">img
src=&quot;http://img-fotki.yandex.ru/get/6725/14441195.30/0_7e0f5_3e107fd4_L.jpg&quot;/</a></p>
<p>And before I wrap up, I cannot stop being delighted by the idea of <a href="https://github.com/bem/project-stub/">BEM project
stub</a>. I use it a lot myself when starting
projects. The <a href="http://bem.info/articles/start-with-project-stub/">Full stack quick start
tutorial</a> which you may
remember demostrates how exactly. So does a friend who asked me about the
basics. I never realized before that the project stub makes is possible to start
a BEM project with no knowledge above. :-)</p>
<p>Having this written I see that describing the BEM basics is pretty easy and not very
time-consuming to me being (I hope!) useful for the others. If so, please ask
what you need to know.</p>
]]></description>
            <link>http://varya.me//en/issues/blocks-and-bundles</link>
            <guid isPermaLink="true">http://varya.me//en/issues/blocks-and-bundles</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 05 Feb 2014 20:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Custom fonts with no cramp]]></title>
            <description><![CDATA[<p>A developer using custom fonts in web (don&#39;t say this is evil) usually face a
dilemma.</p>
<p>The users&#39; main interest is the content of the page not the
view. It is nice to provide it as fast as possible and then apply a custom font.
This blog used to work this way. I provided a script among others in the bundle
linked by the end of the page.</p>
<excerpt/>

<pre class="highlight"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span>{</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFont</span><span class="hljs-params">(url, h, l)</span> {</span>
h = d.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];
l = d.createElement(<span class="hljs-string">'link'</span>);
l.href = url;
l.rel = <span class="hljs-string">'stylesheet'</span>;
h.appendChild(l);
}

addFont(<span class="hljs-string">'//fonts.googleapis.com/css?'</span> +
<span class="hljs-string">'family=Noto+Serif&amp;subset=latin,cyrillic-ext,cyrillic'</span>);

})(document);
</code></pre>
<p>The drawback is obvious. Once a font is loaded and apllied, a user notice
twitching as a page is being re-rendering. It is recommended to define a
suitable system font in the <code>font-face</code>. But there never is a good fit.
Otherwise there was no need in a custom font.</p>
<p>The only way to avoid the font rendering jerk is to provide the font in advance.
With inlining a base64 of a font into CSS and linking it in <code>&lt;head&gt;</code> no
twitching is guaranteed as well as increasing page loading time.</p>
<p>For a while I was deciding between the two variants until my colleague <a href="http://kizu.ru/en/">Roman
Komarov aka kizu</a> suggested an elegant solution which is in
use right now.</p>
<p>At the first time a user opens any page of this site, a CSS with the font is
loaded and stored as a piece of text in the <code>localStorage</code>.</p>
<pre class="highlight"><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(Storage) === <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (localStorage.getItem(<span class="hljs-string">'varya.me.fonts'</span>) === <span class="hljs-literal">null</span>) {

        $.ajax({
            url: <span class="hljs-string">'../../data/fonts.css'</span>,
            success: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span>{</span>
                localStorage.setItem(<span class="hljs-string">'varya.me.fonts'</span>, response);
            },
            dataType: <span class="hljs-string">'text'</span>
        });

    }

});
</code></pre>
<p>But I do not apply this CSS after loading. So, not jerks. As request is only to
fill up the storage, it goes after the <code>domReady</code>.</p>
<p>By the time of requesting the next page the custom font is already in the user&#39;s
computer. Checking that it is available I apply it to the page. The faster the
better, and as the action costs almost nothing an inline <code>&lt;head&gt;</code> script goes
here.</p>
<pre class="highlight"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d, s, l, r)</span> {</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(s) !== <span class="hljs-string">'undefined'</span> &amp;&amp; l.getItem(<span class="hljs-string">'varya.me.fonts'</span>)) {
    r = [
        <span class="hljs-string">'&lt;style&gt;'</span>,
        l.getItem(<span class="hljs-string">'varya.me.fonts'</span>),
        <span class="hljs-string">'&lt;/style&gt;'</span>
    ];
    document.write(r.join(<span class="hljs-string">''</span>));
}

})(document, Storage, localStorage);
</code></pre>
<p>With that the blog looks as it should do with 2+ pages loaded. I consider this
price for no-twitching custom font as reasonable.</p>
<p>Any ideas of making it even better?</p>
]]></description>
            <link>http://varya.me//en/issues/fonts-no-cramp</link>
            <guid isPermaLink="true">http://varya.me//en/issues/fonts-no-cramp</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 25 Dec 2013 20:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>